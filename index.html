<!DOCTYPE html>
<html>
<head>
    <title>QIX Clone</title>
 <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
</head>
<style>
#heart {
}
</style>
<div>
    <body bgcolor="#afafaf">
    <script type="text/javascript">

    var config = {
        type: Phaser.AUTO,
        width: 700,
        height: 700,
        physics: {
            default: 'arcade',
            arcade: {
            gravity: { y: 0 },
            debug: false
        }
        },

        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var game = new Phaser.Game(config);

    var xBorderShift=15;//how far in to shift the game board from the screen width
    var yBorderShift=50;

    var player;
    var enemy;
    var enemyWidth;
    var enemySpeed=0;
    var enemyDirectionX=1;
    var enemyDirectionY=1;
    var cursors;
    var spacebar;
    var gameOver = false;
    var input;
    var slowSpeed = 2;
    var fastSpeed = 2 * slowSpeed;
    var board = []; // pixel values: 1 == is
    var border = [];
    var borderBackup = [];
    var drawMode = 0; //0: none 1:slow 2: fast
    var isDrawing = false;
    var playerIsMoving=false;
    var canvas;
    var whiteColor;
    var _this;
    var graphics;
    var lineGraphics;
    var shadowGraphics;
    var shadowSprite;
    var drawColor = 0xFFFFFF;
    var score = 0;
    var heart1, heart2, heart3;
    var lives = 3;
    var fuse;
    var fuseMaxLength=100;//how many pixels between the fuse start and the player
    var fusePositions=[];
    var fuzeWaitCount=0;
    var closingPointX;
    var closingPointY;
    var movingDir;
    var scoreFactor=0;
    var percentage = 0;

    var bone;

    var sparx1;
    var sparx1Dir=0;

    var sparx2;
    var sparx2Dir=0;

    var scoreText;
    var winText;



    var backTex;
    var frontTex;

    var particleLayer=6;
    var playerLayer=5;
    var fossilLayer=2;
    var UILayer=10;
    var backLayer=1;
    var shadowLayer=3;
    var frontLayer=4;

    var shadowWidth=10;
    var count = 0;

    var bonusScore = 1000000000;

    var collectingScore = 0;
    var remainingPixels = config.width * config.height;

    var boneUncovered = { bool : false };



    // TO GO: in the pixel filler to update score according to conquered pixel spaces
    //
    //scoreText.setText(score += pixelNum);

    function preload ()
    {
        this.load.image('player', 'assets/player.png');
        this.load.image('red', 'assets/red.png');
        this.load.image('green', 'assets/green.png');
        this.load.image('yellow', 'assets/yellow.png');
        this.load.image('enemy','assets/enemy.png');
        this.load.image('sparx','assets/sparx.png')
        this.load.image('heart', 'assets/heart.jpg');
        this.load.image('back','assets/back.png');
        this.load.image('front','assets/front.png');
        this.load.image('bone','assets/bone.png');
    }

    function create ()
    {
      _this = this;

      whiteColor = new Phaser.Display.Color(100, 0, 0);
        cursors = this.input.keyboard.createCursorKeys();
        spacebar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        keys = this.input.keyboard

        player = this.add.sprite(xBorderShift, yBorderShift, 'player');
        enemy= this.add.sprite(config.width/2,config.height/2,'enemy');
        enemy.alpha=0;
        player.alpha=0;

        sparx1 = this.add.sprite(xBorderShift, config.height-yBorderShift, 'sparx');
        sparx1.alpha=0;
        sparx2 = this.add.sprite(config.width-xBorderShift, yBorderShift, 'sparx');
        sparx2.alpha=0;

        fuse = this.add.sprite(-100, -100, 'sparx');
        fuse.alpha=0;

        heart1 = this.add.sprite(425, 25, 'heart');
        heart2 = this.add.sprite(450, 25, 'heart');
        heart3 = this.add.sprite(475, 25, 'heart');
        heart1.setDepth(UILayer);
        heart2.setDepth(UILayer);
        heart3.setDepth(UILayer);

        bone = this.add.sprite(xBorderShift + Math.random()*config.width -xBorderShift, yBorderShift + Math.random()*config.height-yBorderShift, 'bone');
        bone.setDepth(fossilLayer);
        var hintParticles = this.add.particles('yellow');
        var hintEmitter = hintParticles.createEmitter({
            speed: 100,
            scale: { start: .03, end: .02 },
            blendMode: 'ADD'
        });
        hintParticles.setDepth(particleLayer);
        hintEmitter.startFollow(bone);

        scoreText = this.add.text(10, 5, '00', { font: '40px monospace', fill: '#ffffff' });
        scoreText.setDepth(UILayer);
        //this.add.rectangle(0, 0, 100, 100, whiteColor.color);
        enemyWidth = enemy.width;
        graphics = this.add.graphics({ fillStyle: { color: 0x0000aa } });
        lineGraphics = this.add.graphics({ fillStyle: { color: 0x0000aa } });
        lineGraphics.setDepth(playerLayer);

        shadowGraphics = this.add.graphics({ fillStyle: { color: 0x000000, alpha: 0.3 } });
        shadowGraphics.setDepth(shadowLayer);

        //  The score

        //scoreText.sendToFront();

        let scale=3;
        backTex = this.add.sprite(0, 0, 'back');

        backTex.setDisplaySize(backTex.width*scale,backTex.height*scale);
        backTex.setDepth(backLayer);

        frontTex = this.add.sprite(0, 0, 'front');

        frontTex.setDisplaySize(frontTex.width*scale,frontTex.height*scale);
        frontTex.mask = new Phaser.Display.Masks.BitmapMask(this, graphics);
        frontTex.setDepth(frontLayer);



        //graphics.fillRectShape(new Rectangle(xBorderShift,yBorderShift,config.width-xBorderShift,config.height -yBorderShift));

        initBoard();

        var particles = this.add.particles('green');
        var emitter = particles.createEmitter({
            speed: 50,
            scale: { start: .2, end: .02 },
            blendMode: 'ADD'
        });
        particles.setDepth(particleLayer);


        var particles2 = this.add.particles('red');

        var emitter2 = particles2.createEmitter({
            speed: 15,
            scale: { start: .5, end: .01 },
            blendMode: 'ADD'
        });
        particles2.setDepth(particleLayer);

          var sparx1Part = this.add.particles('yellow');

        var sparx1Emitter = sparx1Part.createEmitter({
            speed: 3,
            scale: { start: .08, end: .04 },
            blendMode: 'ADD'
        });
        sparx1Part.setDepth(particleLayer);

        var sparx2Part = this.add.particles('yellow');

        var sparx2Emitter = sparx2Part.createEmitter({
            speed: 3,
            scale: { start: .08, end: .04 },
            blendMode: 'ADD'
        });
        sparx2Part.setDepth(particleLayer);

         var fusePart = this.add.particles('yellow');

        var fuseEmitter = fusePart.createEmitter({
            speed: 10,
            scale: { start: .08, end: .04 },
            blendMode: 'ADD'
        });

        fusePart.setDepth(particleLayer);

        emitter.startFollow(player);
        emitter2.startFollow(enemy);

        sparx1Emitter.startFollow(sparx1);
        sparx2Emitter.startFollow(sparx2);

        fuseEmitter.startFollow(fuse);

        drawBorders();


        // shadowGraphics = graphics.generateTexture("shadow");
        // shadowSprite = this.add.sprite(0,0,"shadow");
        // shadowSprite.setDepth(shadowLayer);
        // shadowSprite.mask = new Phaser.Display.Masks.BitmapMask(this, graphics);
        floodFill(enemy.x,enemy.y);

    }


function update ()
{
    if (gameOver)
    {
      if (count == 0){
        count++;
      }
      else if (count == 1) {
        count++;
      } else if (count == 2) {
        return;
      }

    }

    if(Phaser.Input.Keyboard.JustDown(spacebar) && !isDrawing)
    {
        drawMode++;
        drawMode %= 3;
        console.log(drawMode);
    }

    handleMove();
    updateEnemy();
   sparx1Dir= updateSparx(sparx1, sparx1Dir);
   sparx2Dir= updateSparx(sparx2, sparx2Dir);
}


function updateSparx(sparx, sparxDir)
{
 // 0 right 1 down 2left 3 up
 let newRow = sparx.y;
    let newCol = sparx.x;

    if(sparxDir==0)//right
    {
        newCol++;
        if(onBorder(newRow,newCol))
        {
            sparx.x=newCol;
            sparx1Dir;

        }else
        {
           if(onBorder(sparx.y-1, sparx.x))//check up
           {
            sparxDir=1;
           }else if(onBorder(sparx.y+1, sparx.x))
           {
            sparxDir=3;
           }
        }

    }else  if(sparxDir==1)//up
    {
        newRow--;
        if(onBorder(newRow,newCol))
        {
            sparx.y=newRow;

        }else
        {
            if(onBorder(sparx.y, sparx.x-1))//check LEFT
           {
            sparxDir=2;
           }else if(onBorder(sparx.y, sparx.x+1))
           {
            sparxDir=0;
           }
        }

    }else if(sparxDir==2)//left
    {
        newCol--;
        if(onBorder(newRow,newCol))
        {
            sparx.x=newCol;

        }else
        {
            if(onBorder(sparx.y+1, sparx.x))//check down
           {
            sparxDir=3;
           }else if(onBorder(sparx.y-1, sparx.x))
           {
            sparxDir=1;
           }
        }

    }else if(sparxDir==3)//down
    {
        newRow++;
        if(onBorder(newRow,newCol))
        {
            sparx.y=newRow;

        }else
        {
            if(onBorder(sparx.y, sparx.x-1))//check left
           {
            sparxDir=2;
           }else if(onBorder(sparx.y, sparx.x+1))
           {
            sparxDir=0;
           }
        }

    }
    return sparxDir;
}

function updateEnemy()
{

    for(i=0;i<enemySpeed;i++)
    {
        var newCol= enemy.x+enemyDirectionX;
        var newRow = enemy.y+enemyDirectionY;

//onBorder(newRow,newCol)
//rectOnBorder(enemy.y-enemyWidth/2,enemy.x-enemyWidth/2,enemyWidth)
        if(onBorder(newRow,newCol))
        {
            if((Math.random()*100)<=50)
            {
              enemyDirectionX=-enemyDirectionX;
             }else
             {
             enemyDirectionY=-enemyDirectionY;
             }
        }else
        {
            enemy.x=newCol;
            enemy.y=newRow;
        }

        if(isTemporary(enemy.y,enemy.x))
        {
            killPlayer();
        }
    }

    if((Math.random()*100)<=1)
    {
        if((Math.random()*100)<=50)
        {
            enemyDirectionX=-enemyDirectionX;
        }else
        {
            enemyDirectionY=-enemyDirectionY;
        }
    }
}

//THIS IS TOTALLY BROKEN
function rectOnBorder(topLeftRow, topLeftCol,width)
{
    for(i=0;i<width;i++)
    {
        for(j=0;j<width;j++)
        {
            if(withinScreen(topLeftRow+i,topLeftRow+j) && onBorder(topLeftRow+i,topLeftRow+j))
            {
                return true;
            }
        }
    }
    return false;
}

function get1DIndex(row,col)
{
    if(row < 0 || col < 0)
    {
        return false;
    }
    else if(row >= config.height, col >= config.width)
    {
        return false;
    }

    return row * config.width + col;
}

function initBoard()
{

    for(col = 0; col < config.width; col++)
    {
        for(row = 0; row < config.height; row++)
        {
            //console.log(get1DIndex(row,col));
            border[get1DIndex(row, col)] = 0;

            if(row == 0 || row == config.height - 1)
            {
                border[get1DIndex(row,col)] = 1;
            }

            if(col == 0 || col == config.width - 1)
            {
                border[get1DIndex(row, col)] = 1;
            }
        }
    }

    // Drawing border
    graphics.lineStyle(2, 0xFFFFFF, 1.0);
    graphics.beginPath();
    graphics.moveTo(xBorderShift,yBorderShift);
    graphics.lineTo(xBorderShift, config.height-yBorderShift);
    graphics.closePath();
    graphics.strokePath();
    graphics.lineStyle(2, 0xFFFFFF, 1.0);
    graphics.beginPath();
    graphics.moveTo(xBorderShift,yBorderShift);
    graphics.lineTo(config.width-xBorderShift, yBorderShift);
    graphics.closePath();
    graphics.strokePath();
    graphics.lineStyle(2, 0xFFFFFF, 1.0);
    graphics.beginPath();
    graphics.moveTo(config.width-xBorderShift, yBorderShift);
    graphics.lineTo(config.width-xBorderShift, config.height-yBorderShift);
    graphics.closePath();
    graphics.strokePath();
    graphics.lineStyle(2, 0xFFFFFF, 1.0);
    graphics.beginPath();
    graphics.moveTo(config.width-xBorderShift, config.height-yBorderShift);
    graphics.lineTo(xBorderShift, config.height-yBorderShift);
    graphics.closePath();
    graphics.strokePath();


    for(i=xBorderShift;i<config.width-xBorderShift;i++)
    {
        border[get1DIndex(yBorderShift, i)] = 1;
    }

    for(i=yBorderShift;i<config.height-yBorderShift;i++)
    {
        border[get1DIndex(i, xBorderShift)] = 1;
    }

    for(i=yBorderShift;i<config.height-yBorderShift;i++)
    {
        border[get1DIndex(i, config.width-xBorderShift)] = 1;
    }

    for(i=xBorderShift;i<=config.width-xBorderShift;i++)
    {
        border[get1DIndex(config.height-yBorderShift, i)] = 1;
    }
}


function checkPlayerCollision()
{
    if(sparx1.x==player.x && sparx1.y == player.y)
    {
        killPlayer();
    }


    if(sparx2.x==player.x && sparx2.y == player.y)
    {
        killPlayer();
    }
}


function drawBorders()
{
    for(col = 0; col < config.width; col++)
    {
        for(row = 0;row < config.height; row++)
        {
            var point = border[get1DIndex(row, col)];
            if(point == 1  || point == 2 )
            {
                fillPixel(0xFFFFFF, col, row,lineGraphics);
            }

        }
    }
}

function handleMove()
{

    let speed = 0;
    if(drawMode == 0)
    {
        speed = fastSpeed;
    }
    else if(drawMode == 1)
    {
        speed = slowSpeed;
        drawColor = 0xFF0000;
    }
    else if(drawMode == 2)
    {
        speed = fastSpeed;
        drawColor = 0x0000FF;

    }

    for(i = 0; i < speed; i++)
    {
        playerIsMoving=true;
        checkPlayerCollision();
        let reachedMinPosition = false;
        var newCol = player.x;
        var newRow = player.y;

        if (cursors.left.isDown)
        {
            newCol -= 1;
        }
        else if (cursors.right.isDown)
        {
            newCol += 1;
        }
        else if (cursors.up.isDown)
        {
            newRow -= 1;
        }
        else if (cursors.down.isDown)
        {
            newRow += 1;
        }
        else
        {
            playerIsMoving=false;
            break;
        }

        if(drawMode == 0) //;free move mode
        {
            if(onBorder(newRow,newCol))
            {
                player.x=newCol;
                player.y=newRow;
                reachedMinPosition=true;
            }

        }
        else //drawing mode
        {
            if(!isDrawing)
            {
                if(withinScreen(newRow,newCol) && !isCaptured(newRow, newCol) && !onBorder(newRow, newCol)) //Player is leaving a border
                {
                    console.log("Starting Drawing");
                    borderBackup = border.slice(0); //Backup the current borders in case the player dies and this line will be removed

                    player.x = newCol;
                    player.y = newRow;

                    isDrawing = true;
                    addPlayerPositionToBorder();
                }
                else //stay still this would be an invalid position
                {
                    reachedMinPosition=true;
                }
            }
            else//already drawing
            {
                if(onBorder(newRow,newCol))//player reached a border
                {
                  closingPointX = player.x;
                  closingPointY = player.y;
                  if (newCol - player.x != 0)
                  {
                    movingDir = 0;
                  }
                  else
                  {
                    movingDir = 1;
                  }

                    player.x = newCol;
                    player.y = newRow;
                    reachedMinPosition = true;
                    if (drawMode == 1)
                    {
                      scoreFactor = 2;
                    }
                    else if (drawMode == 2)
                    {
                      scoreFactor = 1;
                    }
                    drawMode = 0;
                    isDrawing = false;
                    processCapture();
                }else if(!isTemporary(newRow,newCol))//player is still drawing move them along as long as they don't cross their own path
                {
                    //THIS IS TEMPORARY LINE BREAKS THINGS
                    player.x=newCol;
                    player.y=newRow;
                    addPlayerPositionToBorder();
                }else//stay still this would be an invalid position
                {
                    reachedMinPosition=true;
                }
            }

            reachedMinPosition = true;
        }
    }

if(isDrawing && !playerIsMoving)
{
    console.log("Penalty");
    updateFuse();
}else
{
    hideFuse();
}

}
function clearFuse()
{

}
function hideFuse()
{
    fuse.x=-9999;
    fuse.y=-9999;

}
function updateFuse()
{

    let newX = fusePositions.shift();
    let newY=fusePositions.shift();
    fuse.x=newX;
    fuse.y=newY

      if(fuse.x==player.x && fuse.y == player.y)
      {
          killPlayer();
      }

}

function isTemporary(row, col)
{
    return (border[get1DIndex(row,col)]==2);
}

function addPlayerPositionToBorder() //Adds the current player position onto the border as a temporary point
{
    border[get1DIndex(player.y, player.x)] = 2;
    fillPixel(player.x, player.y, drawColor,lineGraphics);

    if(fusePositions.length/2>=fuseMaxLength)
    {
        fusePositions.shift();
        fusePositions.shift();
    }
    fusePositions.push(player.x);
    fusePositions.push(player.y);

}

function addAllTemporaryBorders()
{
    for(col = 0; col < config.width; col++)
    {
        for(row = 0;row < config.height; row++)
        {
            //console.log(get1DIndex(row,col));
            if(border[get1DIndex(row, col)] == 2)
            {
                border[get1DIndex(row, col)] = 1;
            }
        }
    }
    lineGraphics.clear();
}

function processCapture()//player has completed a square, process it
{
    graphics.clear();
    shadowGraphics.clear();
    console.log("Done Drawing!");
    addAllTemporaryBorders();
    let startPoint = checkWhichPointToFill();
    floodFill(startPoint[0], startPoint[1]);
    recalcBorders();
   //printBorders();
}
function recalcBorders()
{
    let borderCopy = border.slice(0);//backup the border

    let newBorders =borderFloodFill(borderCopy,enemy.y,enemy.x);
    //console.log(newBorders.length);

    for(col = 0; col < config.width; col++)
    {
        for(row = 0;row < config.height; row++)
        {
          if (border[get1DIndex(row,col)] != -1)
          {
            border[get1DIndex(row,col)]=0;
          }
        }
    }

    while(newBorders.length>0)
    {
        let newY = newBorders.pop();
        let newX = newBorders.pop();
        border[get1DIndex(newY,newX)]=1;
    }



}

function resetEnemyArea()
{
    for(col = 0; col < config.width; col++)
    {
        for(row = 0;row < config.height; row++)
        {
          if (border[get1DIndex(row,col)] != 1)
          {
            border[get1DIndex(row,col)]=0;
          }
        }
    }
}

function borderFloodFill(data,row,col)
{
    let replaceVal=3;

    data[get1DIndex(row,col)]=replaceVal;
    let Qx=[];
    let Qy=[];

    let newBorders = [];

    Qx.push(col);
    Qy.push(row);

    while(!Qx.length==0 && !Qy.length==0)
    {

        let nx = Qx.shift();
        let ny = Qy.shift();


        let north = ny-1;
        let south = ny+1;
        let east = nx+1;
        let west = nx-1;

        if(data[get1DIndex(north,nx)]==1)//if a neighbor is a border it is part of the new borders
        {
            newBorders.push(nx);
            newBorders.push(north);

        }else if (data[get1DIndex(north,nx)]==-1)//otherwise keep floodfilling
        {
            data[get1DIndex(north,nx)]=replaceVal;
            Qx.push(nx);
            Qy.push(north);
        }

        if(data[get1DIndex(south,nx)]==1)
        {
            newBorders.push(nx);
            newBorders.push(south);
        }else if(data[get1DIndex(south,nx)]==-1)
        {
            data[get1DIndex(south,nx)]=replaceVal;
            Qx.push(nx);
            Qy.push(south);
        }

        if(data[get1DIndex(ny,east)]==1)
        {
            newBorders.push(east);
            newBorders.push(ny);

        }else if(data[get1DIndex(ny,east)]==-1)
        {
            data[get1DIndex(ny,east)]=replaceVal;
            Qx.push(east);
            Qy.push(ny);
        }

        if(data[get1DIndex(ny,west)]==1)
        {
            newBorders.push(west);
            newBorders.push(ny);
        }else if(data[get1DIndex(ny,west)]==-1)
        {
            data[get1DIndex(ny,west)]=replaceVal;
            Qx.push(west);
            Qy.push(ny);
        }


        if(data[get1DIndex(north,west)]==1)
        {
            newBorders.push(west);
            newBorders.push(north);
        }


        if(data[get1DIndex(north,east)]==1)
        {
            newBorders.push(east);
            newBorders.push(north);
        }


        if(data[get1DIndex(south,east)]==1)
        {
            newBorders.push(east);
            newBorders.push(south);
        }

        if(data[get1DIndex(south,west)]==1)
        {
            newBorders.push(west);
            newBorders.push(south);
        }
    }
    return newBorders;
}

function checkWhichPointToFill()
{

//TESTING
return [enemy.x,enemy.y];

  if (movingDir == 0)
  {
    if (checkCaptured(closingPointX, closingPointY + 1))
    {
      return [closingPointX, closingPointY + 1];
    }
    else
    {
      return [closingPointX, closingPointY - 1];
    }
  }
  else if (movingDir == 1)
  {
    if (checkCaptured(closingPointX + 1, closingPointY))
    {
      return [closingPointX + 1, closingPointY];
    }
    else
    {
      return [closingPointX - 1, closingPointY];
    }
  }
}

function checkCaptured(x, y)
{
  if (onBorder(y, x))
  {
    return;
  }

  if (enemy.x == x && enemy.y == y)
  {
    return false;
  }

  var queue = [];
  var set = [];

  queue.push(x);
  queue.push(y);

  set[get1DIndex(y, x)] = 1;

  while (queue.length > 0)
  {
    var tempX = queue.shift();
    var tempY = queue.shift();

    if (enemy.x == tempX && enemy.y == tempY)
    {
      return false;
    }

    if (!onBorder(tempY + 1, tempX) && set[get1DIndex(tempY + 1, tempX)] != 1)
    {
      set[get1DIndex(tempY + 1, tempX)] = 1;
      queue.push(tempX);
      queue.push(tempY + 1);
    }

    if (!onBorder(tempY - 1, tempX) && set[get1DIndex(tempY - 1, tempX)] != 1)
    {
      set[get1DIndex(tempY - 1, tempX)] = 1;
      queue.push(tempX);
      queue.push(tempY - 1);
    }

    if (!onBorder(tempY, tempX + 1) && set[get1DIndex(tempY, tempX + 1)] != 1)
    {
      set[get1DIndex(tempY, tempX + 1)] = 1;
      queue.push(tempX + 1);
      queue.push(tempY);
    }

    if (!onBorder(tempY, tempX - 1) && set[get1DIndex(tempY, tempX - 1)] != 1)
    {
      set[get1DIndex(tempY, tempX - 1)] = 1;
      queue.push(tempX - 1);
      queue.push(tempY);
    }
  }

  return true;
}

function printBorders()
{
    for(col = 0; col < config.width; col++)
    {
        for(row = 0;row < config.height; row++)
        {
          if(border[get1DIndex(row,col)]==1)
          {
              console.log(row+" "+col);
          }
        }
    }
}

function isCaptured(row, col)//Will eventually tell whether this point has been captured
{
    return false;
}

function withinScreen(row, col)
{
    if(row < yBorderShift || col < xBorderShift)
    {
        return false;
    }
    else if(row >= config.height-yBorderShift || col >= config.width-xBorderShift)
    {
        return false;
    }

    return true;
}

function onBorder(row, col)
{
    //console.log(row+" "+col);
    if( border[get1DIndex(row,col)]==1)
    {
        return true;
    }

    return false;
}

function fillPixel(x, y, color, graphicsObj)
{
  var rect = new Phaser.Geom.Rectangle(x, y, 1, 1);
  //rect.setDepth(UILayer);
  graphicsObj.fillStyle(color, 1.0);
  graphicsObj.fillRectShape(rect);
}

function killPlayer()
{
    if (count == 0) {
      heart1.visible = false;
      player.x = player.x;
      player.y = player.y;
      count++; // lives used
    } else if (count == 1) {
      heart2.visible = false;
      player.x = player.x;
      player.y = player.y;
      count++;
    } else if (count == 2) {
      heart3.visible = false;
      player.x=-999;
      player.y=-999;
      enemySpeed=0;
    }

}

function checkUncover(bSprite, bUncovered)
{
  if (bUncovered.bool)
  {
    return;
  }

  let rec = bSprite.getBounds();
  let recLeft = Math.round(rec.left);
  let recRight = Math.round(rec.right);
  let recTop = Math.round(rec.top);
  let recBottom = Math.round(rec.bottom);
  console.log(border[get1DIndex(recTop, recLeft)]);
  console.log(border[get1DIndex(recTop, recRight)]);
  console.log(border[get1DIndex(recBottom, recLeft)]);
  console.log(border[get1DIndex(recBottom, recRight)]);

  if ((border[get1DIndex(recTop, recLeft)] != -1) && (border[get1DIndex(recTop, recRight)] != -1) && (border[get1DIndex(recBottom, recLeft)] != -1) && (border[get1DIndex(recBottom, recRight)] != -1))
  {
    collectingScore += bonusScore;
    bUncovered.bool = true;
  }
}

function floodFill(x, y)
{
  resetEnemyArea();
  let tempScore = 0;

  if (onBorder(y, x))
  {
    return;
  }

  graphics.fillPoint(x, y);//Is this needed?

  var queue = [];
  var set = [];

  queue.push(x);
  queue.push(y);

  set[get1DIndex(y, x)] = 1;
  border[get1DIndex(y, x)] = -1;

  var shapeBorderSet = [];
  var startingX = x;
  var startingY = y;

  tempScore++;

  while (queue.length > 0)
  {
    var tempX = queue.shift();
    var tempY = queue.shift();

    if (!onBorder(tempY + 1, tempX) && set[get1DIndex(tempY + 1, tempX)] != 1)
    {
      tempScore++;
      //graphics.fillPoint(tempX, tempY + 1);
      set[get1DIndex(tempY + 1, tempX)] = 1;
      queue.push(tempX);
      queue.push(tempY + 1);
      border[get1DIndex(tempY + 1, tempX)] = -1;
    }
    else if (onBorder(tempY + 1, tempX))
    {
      shapeBorderSet[get1DIndex(tempY, tempX)] = 1;
      if (tempX > startingX)
      {
        startingX = tempX;
        startingY = tempY;
      }
    }

    if (!onBorder(tempY - 1, tempX) && set[get1DIndex(tempY - 1, tempX)] != 1)
    {
      tempScore++;
      //graphics.fillPoint(tempX, tempY - 1);
      set[get1DIndex(tempY - 1, tempX)] = 1;
      queue.push(tempX);
      queue.push(tempY - 1);
      border[get1DIndex(tempY - 1, tempX)] = -1;
    }
    else if (onBorder(tempY - 1, tempX))
    {
      shapeBorderSet[get1DIndex(tempY, tempX)] = 1;
      if (tempX > startingX)
      {
        startingX = tempX;
        startingY = tempY;
      }
    }

    if (!onBorder(tempY, tempX + 1) && set[get1DIndex(tempY, tempX + 1)] != 1)
    {
      tempScore++;
      //graphics.fillPoint(tempX + 1, tempY);
      set[get1DIndex(tempY, tempX + 1)] = 1;
      queue.push(tempX + 1);
      queue.push(tempY);
      border[get1DIndex(tempY, tempX + 1)] = -1;
    }
    else if (onBorder(tempY, tempX + 1))
    {
      shapeBorderSet[get1DIndex(tempY, tempX)] = 1;
      if (tempX > startingX)
      {
        startingX = tempX;
        startingY = tempY;
      }
    }

    if (!onBorder(tempY, tempX - 1) && set[get1DIndex(tempY, tempX - 1)] != 1)
    {
      tempScore++;
      //graphics.fillPoint(tempX - 1, tempY);
      set[get1DIndex(tempY, tempX - 1)] = 1;
      queue.push(tempX - 1);
      queue.push(tempY);
      border[get1DIndex(tempY, tempX - 1)] = -1;
    }
    else if (onBorder(tempY, tempX - 1))
    {
      shapeBorderSet[get1DIndex(tempY, tempX)] = 1;
      if (tempX > startingX)
      {
        startingX = tempX;
        startingY = tempY;
      }
    }
  }

  checkUncover(bone, boneUncovered);

  score = Math.round(collectingScore + scoreFactor * (remainingPixels - tempScore) / 100);
  remainingPixels = tempScore;

  // TODO: Check every bone
  // TEMP: Check a single bone

  scoreText.setText(score);
  percentage = percentage + tempScore;

 // console.log(percentage);

  //console.log(percentage / (config.width * config.height));

  //console.log(config.width * config.height);

  // TEMPORARY: win text
  if (percentage / (config.width * config.height) > 0.75)
  {
   // _this.add.text(175, 230, 'You Win!', { font: '40px monospace', fill: '#ffffff' });
  }

  var checkingDir;
  var runningX;
  var runningY;

  //console.log(startingX);
  //console.log(startingY);

  if (shapeBorderSet[get1DIndex(startingY, startingX + 1)] == 1)
  {
    //console.log("right");
    checkingDir = 0;
    runningX = startingX + 1;
    runningY = startingY;
  }
  /*else if (shapeBorderSet[get1DIndex(startingY, startingX - 1)] == 1)
  {
    //console.log("left");
    checkingDir = 1;
    runningX = startingX - 1;
    runningY = startingY;
  }*/
  else// if (shapeBorderSet[get1DIndex(startingY + 1, startingX)] == 1)
  {
    //console.log("up");
    checkingDir = 2;
    runningX = startingX;
    runningY = startingY;
  }
  /*else if (shapeBorderSet[get1DIndex(startingY - 1, startingX)] == 1)
  {
    //console.log("down");
    checkingDir = 3;
    runningX = startingX;
    runningY = startingY - 1;
  }*/

  var corners = [];

  var shadowCorners = [];

  //corners.push(new Phaser.Geom.Point(startingX, startingY));
  //shadowCorners.push()

  let check = true;
  let lastCheck = false;

  //while (!((startingX == runningX) && (startingY == runningY)))
  while (check)
  {
    if (checkingDir == 0)
    {
      if (shapeBorderSet[get1DIndex(runningY, runningX + 1)] != 1)
      {
        corners.push(new Phaser.Geom.Point(runningX, runningY));
        if (shapeBorderSet[get1DIndex(runningY + 1, runningX)] == 1)
        {
          //console.log("up");
          runningY++;
          checkingDir = 2;
          shadowCorners.push(new Phaser.Geom.Point(runningX + shadowWidth, runningY - shadowWidth));
        }
        else if (shapeBorderSet[get1DIndex(runningY - 1, runningX)] == 1)
        {
          //console.log("down");
          runningY--;
          checkingDir = 3;
          shadowCorners.push(new Phaser.Geom.Point(runningX - shadowWidth, runningY - shadowWidth));
        }
        else{
          runningX++;
        }
      }
      else if (shapeBorderSet[get1DIndex(runningY, runningX + 1)] == 1)
      {
        runningX++;
      }
    }
    else if (checkingDir == 1)
    {
      if (shapeBorderSet[get1DIndex(runningY, runningX - 1)] != 1)
      {
        corners.push(new Phaser.Geom.Point(runningX, runningY));
        if (shapeBorderSet[get1DIndex(runningY + 1, runningX)] == 1)
        {
          //console.log("up");
          runningY++;
          checkingDir = 2;
          shadowCorners.push(new Phaser.Geom.Point(runningX + shadowWidth, runningY + shadowWidth));
        }
        else if (shapeBorderSet[get1DIndex(runningY - 1, runningX)] == 1)
        {
          //console.log("down");
          runningY--;
          checkingDir = 3;
          shadowCorners.push(new Phaser.Geom.Point(runningX - shadowWidth, runningY + shadowWidth));
        }
        else{
          runningX--;
        }
      }
      else
      {
        runningX--;
      }
    }
    else if (checkingDir == 2)
    {
      if (shapeBorderSet[get1DIndex(runningY + 1, runningX)] != 1)
      {
        corners.push(new Phaser.Geom.Point(runningX, runningY));
        if (shapeBorderSet[get1DIndex(runningY, runningX + 1)] == 1)
        {
          //console.log("right");
          runningX++;
          checkingDir = 0;
          shadowCorners.push(new Phaser.Geom.Point(runningX + shadowWidth, runningY - shadowWidth));
        }
        else if (shapeBorderSet[get1DIndex(runningY, runningX - 1)] == 1)
        {
          //console.log("left");
          runningX--;
          checkingDir = 1;
          shadowCorners.push(new Phaser.Geom.Point(runningX + shadowWidth, runningY + shadowWidth));
        }
        else {
          runningY++;
        }
      }
      else
      {
        runningY++;
      }
    }
    else if (checkingDir == 3)
    {
      if (shapeBorderSet[get1DIndex(runningY - 1, runningX)] != 1)
      {
        corners.push(new Phaser.Geom.Point(runningX, runningY));
        if (shapeBorderSet[get1DIndex(runningY, runningX + 1)] == 1)
        {
          //console.log("right");
          runningX++;
          checkingDir = 0;
          shadowCorners.push(new Phaser.Geom.Point(runningX - shadowWidth, runningY - shadowWidth));
        }
        else if (shapeBorderSet[get1DIndex(runningY, runningX - 1)] == 1)
        {
          //console.log("left");
          runningX--;
          checkingDir = 1;
          shadowCorners.push(new Phaser.Geom.Point(runningX - shadowWidth, runningY + shadowWidth));
        }
        else {
          runningY--;
        }
      }
      else
      {
        runningY--;
      }
    }

    if (lastCheck)
    {
      check = false;
    }

    if ((startingX == runningX) && (startingY == runningY))
    {
      lastCheck = true;
    }
  }

  //console.log(corners.length);
 // graphics.fillStyle(0xFFFFFF, 1.0);

  // let thick = graphics.thickness;
  // let alpha = graphics.alpha;
  // let color = graphics.color;

 // graphics.lineStyle(50,0xFFFFFF,.8);
  graphics.fillPoints(corners, true);
  shadowGraphics.fillPoints(shadowCorners, true);

   //graphics.lineStyle(50,0xFFFFFF,.4);
   //graphics.strokePoints(corners,true);
   //graphics.lineStyle(thick,color,alpha);

  //shadowGraphics = graphics.generateTexture("shadow");
  //shadowSprite.setTexture("shadow");


 // let scale =3.1;
  //shadowSprite.setDisplaySize(shadowSprite.width*scale,shadowSprite.height*scale);
  //shadowSprite.tint = 0x000000;
 //shadowSprite.alpha = 0.6;


}
    </script>
</body>
</div>

<div>
<p>Welcome to Qix! Ccontrol the green character with the arrow keys. </p>
<p>Press space to activate drawing mode and try to capture 75% of the board in your squares.</p>
<p>Press space twice for fast drawing mode. Safer but awards fewer points.</p>
<p>Don't stop while drawing and watch out for enemies on the board. </p>
</div>
</html>

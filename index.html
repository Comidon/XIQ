<!DOCTYPE html>
<html>
<head>
    <title>QIX Clone</title>
 <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>
    <script type="text/javascript">

    var config = {
        type: Phaser.AUTO,
        width: 500,
        height: 500,
        physics: {
            default: 'arcade',
            arcade: {
            gravity: { y: 0 },
            debug: false
        }
        },

        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var game = new Phaser.Game(config);
    var player;
    var cursors;
    var spacebar;
    var gameOver = false;
    var input;
    var slowSpeed = 5;
    var fastSpeed = 2 * slowSpeed;
    var board = [];
    var border = [];
    var borderBackup = [];
    var drawMode = 0; //0: none 1:slow 2: fast
    var isDrawing = false;
    var canvas;
    var whiteColor;
    var _this;
    var graphics;
    var drawColor =0xFFFFFF;

    function preload ()
    {
        this.load.image('player', 'assets/player.png');
        this.load.image('red', 'assets/red.png');
    }

    function create ()
    {
      _this = this;
      graphics = this.add.graphics({ fillStyle: { color: 0x0000aa } });
      whiteColor = new Phaser.Display.Color(100, 0, 0);
        cursors = this.input.keyboard.createCursorKeys();
        spacebar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        keys = this.input.keyboard
        player = this.add.sprite(240, 490, 'player');
        //this.add.rectangle(0, 0, 100, 100, whiteColor.color);

        initBoard();

        var particles = this.add.particles('red');
        var emitter = particles.createEmitter({
            speed: 50,
            scale: { start: .2, end: .01 },
            blendMode: 'ADD'
        });

        emitter.startFollow(player);

        drawBorders();
    }

function get1DIndex(row, col)
{
    if(row < 0 || col < 0)
    {
        return false;
    }
    else if(row >= config.height, col >= config.width)
    {
        return false;
    }

    return row * config.width + col;
}

function initBoard()
{
    // Drawing border
    graphics.lineStyle(2, 0xFFFFFF, 1.0);
    graphics.beginPath();
    graphics.moveTo(10, 10);
    graphics.lineTo(10, 490);
    graphics.closePath();
    graphics.strokePath();
    graphics.lineStyle(2, 0xFFFFFF, 1.0);
    graphics.beginPath();
    graphics.moveTo(10, 10);
    graphics.lineTo(490, 10);
    graphics.closePath();
    graphics.strokePath();
    graphics.lineStyle(2, 0xFFFFFF, 1.0);
    graphics.beginPath();
    graphics.moveTo(490, 10);
    graphics.lineTo(490, 490);
    graphics.closePath();
    graphics.strokePath();
    graphics.lineStyle(2, 0xFFFFFF, 1.0);
    graphics.beginPath();
    graphics.moveTo(490, 490);
    graphics.lineTo(10, 490);
    graphics.closePath();
    graphics.strokePath();

    for(col = 0; col < config.width; col++)
    {
        for(row = 0; row < config.height; row++)
        {
            //console.log(get1DIndex(row,col));
            border[get1DIndex(row, col)] = 0;

            if(row == 0 || row == config.height - 1)
            {
                border[get1DIndex(row,col)] = 1;
            }

            if(col == 0 || col == config.width - 1)
            {
                border[get1DIndex(row, col)] = 1;
            }
        }
    }
}

function update ()
{
    if (gameOver)
    {
        return;
    }

    if(Phaser.Input.Keyboard.JustDown(spacebar) && !isDrawing)
    {
        drawMode++;
        drawMode %= 3;
        console.log(drawMode);
    }

    handleMove();


}

function drawBorders()
{
    for(col = 0; col < config.width; col++)
    {
        for(row = 0;row < config.height; row++)
        {
            var point = border[get1DIndex(row, col)];
            if(point == 1  || point == 2 )
            {
                fillPixel(0xFFFFFF, col, row);
            }

        }
    }
}

function handleMove()
{

    let speed = 0;
    if(drawMode == 0)
    {
        speed = slowSpeed;
    }
    else if(drawMode == 1)
    {
        speed = slowSpeed;
        drawColor = 0x0000FF;
    }
    else if(drawMode == 2)
    {
        speed = fastSpeed;
        drawColor = 0xFF0000;
    }

    for(i = 0; i < speed; i++)
    {
        let reachedMinPosition = false;
        var newCol = player.x;
        var newRow = player.y;

        if (cursors.left.isDown && player.x > 10)
        {
            newCol -= 1;
        }
        else if (cursors.right.isDown && player.x < 490)
        {
            newCol += 1;
        }
        else if (cursors.up.isDown && player.y > 10)
        {
            newRow -= 1;
        }
        else if (cursors.down.isDown && player.y < 490)
        {
            newRow+=1;
        }
        else
        {
            return; //if no keys were pressed then do nothing
        }

        if(drawMode == 0) //;free move mode
        {
            if(onBorder(newRow,newCol))
            {
                player.x=newCol;
                player.y=newRow;
                reachedMinPosition=true;
            }

        }
        else //drawing mode
        {
            if(!isDrawing)
            {
                if(withinScreen(newRow,newCol) && !isCaptured(newRow, newCol)) //Player is leaving a border
                {
                    console.log("Starting Drawing");
                    borderBackup = border.slice(0); //Backup the current borders in case the player dies and this line will be removed

                    player.x = newCol;
                    player.y = newRow;

                    isDrawing = true;
                    addPlayerPositionToBorder();
                }
                else //stay still this would be an invalid position
                {
                    reachedMinPosition=true;
                }
            }
            else//already drawing
            {
                if(onBorder(newRow,newCol))//player reached a border
                {
                    player.x = newCol;
                    player.y = newRow;
                    reachedMinPosition = true;
                    drawMode = 0;
                    isDrawing = false;
                    processCapture();
                }
                else if(isTemporary(newRow,newCol))//player is still drawing move them along as long as they don't cross their own path
                {
                    //THIS IS TEMPORARY LINE BREAKS THINGS
                    player.x = newCol;
                    player.y = newRow;
                    addPlayerPositionToBorder();
                }
            }

            reachedMinPosition = true;
        }
    }
}

function isTemporary(row, col)
{
    return border[get1DIndex(player.y, player.x)] == 2;
}

function addPlayerPositionToBorder() //Adds the current player position onto the border as a temporary point
{
    border[get1DIndex(player.y,player.x)] = 2;
    fillPixel(player.x, player.y, drawColor);
}

function addAllTemporaryBorders()
{
    for(col = 0; col < config.width; col++)
    {
        for(row = 0;row < config.height; row++)
        {
            //console.log(get1DIndex(row,col));
            if(border[get1DIndex(row, col)] == 2)
            {
                border[get1DIndex(row, col)] = 1;
            }
        }
    }
}

function processCapture()//player has completed a square, process it
{
    console.log("Done Drawing!");
    addAllTemporaryBorders();
}

function isCaptured(row, col)//Will eventually tell whether this point has been captured
{
    return false;
}

function withinScreen(row, col)
{
    if(row < 0 || col < 0)
    {
        return false;
    }
    else if(row >= config.height, col >= config.width)
    {
        return false;
    }

    return true;
}

function onBorder(row, col)
{
    //console.log(row+" "+col);
    if( border[get1DIndex(row,col)]==2)
    {
        return true;
    }

    return false;
}

function fillPixel(x, y, color)
{
  var rect = new Phaser.Geom.Rectangle(x, y, 1, 1);
  graphics.fillStyle(color, 1.0);
  graphics.fillRectShape(rect);
}


    </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <title>QIX Clone</title>
 <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>
    <script type="text/javascript">

    var config = {
        type: Phaser.AUTO,
        width: 500,
        height: 510,
        physics: {
            default: 'arcade',
            arcade: {
            gravity: { y: 0 },
            debug: false
        }
        },

        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var game = new Phaser.Game(config);

    var xBorderShift=5;//how far in to shift the game board from the screen width
    var yBorderShift=5;

    var player;
    var enemy;
    var enemyWidth;
    var enemySpeed=4;
    var enemyDirectionX=1;
    var enemyDirectionY=1;
    var cursors;
    var spacebar;
    var gameOver = false;
    var input;
    var slowSpeed = 5;
    var fastSpeed = 2 * slowSpeed;
    var board = [];
    var border = [];
    var borderBackup = [];
    var drawMode = 0; //0: none 1:slow 2: fast
    var isDrawing = false;
    var canvas;
    var whiteColor;
    var _this;
    var graphics;
    var drawColor = 0xFFFFFF;
    var score = 0;

    var sparx1;
    var sparx2;

    function preload ()
    {
        this.load.image('player', 'assets/player.png');
        this.load.image('red', 'assets/red.png');
        this.load.image('enemy','assets/enemy.png');
        this.load.image('sparx','assets/sparx.png')

    }

    var bpmText;

    function create ()
    {
      _this = this;
      graphics = this.add.graphics({ fillStyle: { color: 0x0000aa } });
      whiteColor = new Phaser.Display.Color(100, 0, 0);
        cursors = this.input.keyboard.createCursorKeys();
        spacebar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        keys = this.input.keyboard

        player = this.add.sprite(xBorderShift, yBorderShift, 'player');
        enemy= this.add.sprite(config.width/2,config.height/2,'enemy');

        sparx1 = this.add.sprite(xBorderShift, config.height-yBorderShift, 'sparx');
        sparx2 = this.add.sprite(config.width-xBorderShift, yBorderShift, 'sparx');



        //this.add.rectangle(0, 0, 100, 100, whiteColor.color);
        enemyWidth = enemy.width;

        //  The score
        scoreText = this.add.text(420, 5, '00', { font: '40px monospace', fill: '#ffffff' });

        initBoard();

        var particles = this.add.particles('red');
        var emitter = particles.createEmitter({
            speed: 50,
            scale: { start: .08, end: .01 },
            blendMode: 'ADD'
        });


        var particles2 = this.add.particles('red');

        var emitter2 = particles2.createEmitter({
            speed: 50,
            scale: { start: .2, end: .01 },
            blendMode: 'ADD'
        });

        emitter.startFollow(player);
        emitter2.startFollow(enemy);
        drawBorders();

    }



function updateEnemy()
{

    for(i=0;i<enemySpeed;i++)
    {
        var newCol= enemy.x+enemyDirectionX;
        var newRow = enemy.y+enemyDirectionY;

//onBorder(newRow,newCol)
//rectOnBorder(enemy.y-enemyWidth/2,enemy.x-enemyWidth/2,enemyWidth)
        if(onBorder(newRow,newCol))
        {
            if((Math.random()*100)<=50)
            {
              enemyDirectionX=-enemyDirectionX;
             }else
             {
             enemyDirectionY=-enemyDirectionY;
             }
        }else
        {
            enemy.x=newCol;
            enemy.y=newRow;
        }

    }

    if((Math.random()*100)<=1)
    {
        if((Math.random()*100)<=50)
        {
            enemyDirectionX=-enemyDirectionX;
        }else
        {
            enemyDirectionY=-enemyDirectionY;
        }
    }


}

//THIS IS TOTALLY BROKEN
function rectOnBorder(topLeftRow, topLeftCol,width)
{
    for(i=0;i<width;i++)
    {
        for(j=0;j<width;j++)
        {
            if(withinScreen(topLeftRow+i,topLeftRow+j) && onBorder(topLeftRow+i,topLeftRow+j))
            {
                return true;
            }
        }
    }
    return false;
}

function get1DIndex(row,col)
{
    if(row < 0 || col < 0)
    {
        return false;
    }
    else if(row >= config.height, col >= config.width)
    {
        return false;
    }

    return row * config.width + col;
}

function initBoard()
{
  
    for(col = 0; col < config.width; col++)
    {
        for(row = 0; row < config.height; row++)
        {
            //console.log(get1DIndex(row,col));
            border[get1DIndex(row, col)] = 0;

            if(row == 0 || row == config.height - 1)
            {
                border[get1DIndex(row,col)] = 1;
            }

            if(col == 0 || col == config.width - 1)
            {
                border[get1DIndex(row, col)] = 1;
            }
        }
    }

    // Drawing border
    graphics.lineStyle(2, 0xFFFFFF, 1.0);
    graphics.beginPath();
    graphics.moveTo(xBorderShift,yBorderShift);
    graphics.lineTo(xBorderShift, config.height-yBorderShift);
    graphics.closePath();
    graphics.strokePath();
    graphics.lineStyle(2, 0xFFFFFF, 1.0);
    graphics.beginPath();
    graphics.moveTo(xBorderShift,yBorderShift);
    graphics.lineTo(config.width-xBorderShift, yBorderShift);
    graphics.closePath();
    graphics.strokePath();
    graphics.lineStyle(2, 0xFFFFFF, 1.0);
    graphics.beginPath();
    graphics.moveTo(config.width-xBorderShift, yBorderShift);
    graphics.lineTo(config.width-xBorderShift, config.height-yBorderShift);
    graphics.closePath();
    graphics.strokePath();
    graphics.lineStyle(2, 0xFFFFFF, 1.0);
    graphics.beginPath();
    graphics.moveTo(config.width-xBorderShift, config.height-yBorderShift);
    graphics.lineTo(xBorderShift, config.height-yBorderShift);
    graphics.closePath();
    graphics.strokePath();


    for(i=xBorderShift;i<config.width-xBorderShift;i++)
    {
        border[get1DIndex(yBorderShift, i)] = 1;
    }

    for(i=yBorderShift;i<config.height-yBorderShift;i++)
    {
        border[get1DIndex(i, xBorderShift)] = 1;
    }

    for(i=yBorderShift;i<config.height-yBorderShift;i++)
    {
        border[get1DIndex(i, config.width-xBorderShift)] = 1;
    }

    for(i=xBorderShift;i<=config.width-xBorderShift;i++)
    {
        border[get1DIndex(config.height-yBorderShift, i)] = 1;
    }



  
}

function update ()
{
    if (gameOver)
    {
        return;
    }

    if(Phaser.Input.Keyboard.JustDown(spacebar) && !isDrawing)
    {
        drawMode++;
        drawMode %= 3;
        console.log(drawMode);
    }

    handleMove();
    updateEnemy();


}

function drawBorders()
{
    for(col = 0; col < config.width; col++)
    {
        for(row = 0;row < config.height; row++)
        {
            var point = border[get1DIndex(row, col)];
            if(point == 1  || point == 2 )
            {
                fillPixel(0xFFFFFF, col, row);
            }

        }
    }
}

function handleMove()
{

    let speed = 0;
    if(drawMode == 0)
    {
        speed = slowSpeed;
    }
    else if(drawMode == 1)
    {
        speed = slowSpeed;
        drawColor = 0x0000FF;
    }
    else if(drawMode == 2)
    {
        speed = fastSpeed;
        drawColor = 0xFF0000;
    }

    for(i = 0; i < speed; i++)
    {
        let reachedMinPosition = false;
        var newCol = player.x;
        var newRow = player.y;

        if (cursors.left.isDown)
        {
            newCol -= 1;
        }
        else if (cursors.right.isDown)
        {
            newCol += 1;
        }
        else if (cursors.up.isDown)
        {
            newRow -= 1;
        }
        else if (cursors.down.isDown)
        {
            newRow += 1;
        }
        else
        {
            return; //if no keys were pressed then do nothing
        }

        if(drawMode == 0) //;free move mode
        {
            if(onBorder(newRow,newCol))
            {
                player.x=newCol;
                player.y=newRow;
                reachedMinPosition=true;
            }

        }
        else //drawing mode
        {
            if(!isDrawing)
            {
                if(withinScreen(newRow,newCol) && !isCaptured(newRow, newCol)) //Player is leaving a border
                {
                    console.log("Starting Drawing");
                    borderBackup = border.slice(0); //Backup the current borders in case the player dies and this line will be removed

                    player.x = newCol;
                    player.y = newRow;

                    isDrawing = true;
                    addPlayerPositionToBorder();
                }
                else //stay still this would be an invalid position
                {
                    reachedMinPosition=true;
                }
            }
            else//already drawing
            {
                if(onBorder(newRow,newCol))//player reached a border
                {
                    player.x = newCol;
                    player.y = newRow;
                    reachedMinPosition = true;
                    drawMode = 0;
                    isDrawing = false;
                    processCapture();
                }else if(!isTemporary(newRow,newCol))//player is still drawing move them along as long as they don't cross their own path
                {
                    //THIS IS TEMPORARY LINE BREAKS THINGS
                    player.x=newCol;
                    player.y=newRow;
                    addPlayerPositionToBorder();
                }else//stay still this would be an invalid position
                {
                    reachedMinPosition=true;
                }
            }

            reachedMinPosition = true;
        }
    }
}

function isTemporary(row, col)
{
    return (border[get1DIndex(row,col)]==2);
}

function addPlayerPositionToBorder() //Adds the current player position onto the border as a temporary point
{
    border[get1DIndex(player.y, player.x)] = 2;
    fillPixel(player.x, player.y, drawColor);
}

function addAllTemporaryBorders()
{
    for(col = 0; col < config.width; col++)
    {
        for(row = 0;row < config.height; row++)
        {
            //console.log(get1DIndex(row,col));
            if(border[get1DIndex(row, col)] == 2)
            {
                border[get1DIndex(row, col)] = 1;
            }
        }
    }
}

function processCapture()//player has completed a square, process it
{
    console.log("Done Drawing!");  
    addAllTemporaryBorders();  
    recalcBorders();
   printBorders();
}
function recalcBorders()
{
    let borderCopy = border.slice(0);//backup the border

    let newBorders =borderFloodFill(borderCopy,enemy.y,enemy.x);
    //console.log(newBorders.length);

    for(col = 0; col < config.width; col++)
    {
        for(row = 0;row < config.height; row++)
        {
          border[get1DIndex(row,col)]=0;
        }
    }

    while(newBorders.length>0)
    {
        let newY = newBorders.pop();
        let newX = newBorders.pop();
        border[get1DIndex(newY,newX)]=1;
    }

}

function borderFloodFill(data,row,col)
{
    let replaceVal=3;

    data[get1DIndex(row,col)]=replaceVal;
    let Qx=[];
    let Qy=[];

    let newBorders = [];

    Qx.push(col);
    Qy.push(row);

    while(!Qx.length==0 && !Qy.length==0)
    {
       
        let nx = Qx.shift();
        let ny = Qy.shift();
       

        let north = ny-1;
        let south = ny+1;
        let east = nx+1;
        let west = nx-1;
        
        if(data[get1DIndex(north,nx)]==1)//if a neighbor is a border it is part of the new borders
        {           
            newBorders.push(nx);
            newBorders.push(north);

        }else if (data[get1DIndex(north,nx)]==0)//otherwise keep floodfilling
        {
            data[get1DIndex(north,nx)]=replaceVal;
            Qx.push(nx);
            Qy.push(north);
        }

        if(data[get1DIndex(south,nx)]==1)
        {
            newBorders.push(nx);
            newBorders.push(south);
        }else if(data[get1DIndex(south,nx)]==0)
        {
            data[get1DIndex(south,nx)]=replaceVal;
            Qx.push(nx);
            Qy.push(south);
        }

        if(data[get1DIndex(ny,east)]==1)
        {
            newBorders.push(east);
            newBorders.push(ny);

        }else if(data[get1DIndex(ny,east)]==0)
        {
            data[get1DIndex(ny,east)]=replaceVal;
            Qx.push(east);
            Qy.push(ny);
        }

        if(data[get1DIndex(ny,west)]==1)
        {
            newBorders.push(west);
            newBorders.push(ny);
        }else  if(data[get1DIndex(ny,west)]==0)
        {
            data[get1DIndex(ny,west)]=replaceVal;
            Qx.push(west);
            Qy.push(ny);
        }

        
        if(data[get1DIndex(north,west)]==1)
        {
            newBorders.push(west);
            newBorders.push(north);
        }

         
        if(data[get1DIndex(north,east)]==1)
        {
            newBorders.push(east);
            newBorders.push(north);
        }

          
        if(data[get1DIndex(south,east)]==1)
        {
            newBorders.push(east);
            newBorders.push(south);
        }

        if(data[get1DIndex(south,west)]==1)
        {
            newBorders.push(west);
            newBorders.push(south);
        }





    }  
    return newBorders;
    
}


function printBorders()
{
    for(col = 0; col < config.width; col++)
    {
        for(row = 0;row < config.height; row++)
        {
          if(border[get1DIndex(row,col)]==1)
          {
              console.log(row+" "+col);
          }
        }
    }
}

function isCaptured(row, col)//Will eventually tell whether this point has been captured
{
    return false;
}

function withinScreen(row, col)
{
    if(row < yBorderShift || col < xBorderShift)
    {
        return false;
    }
    else if(row >= config.height-yBorderShift || col >= config.width-xBorderShift)
    {
        return false;
    }

    return true;
}

function onBorder(row, col)
{
    //console.log(row+" "+col);
    if( border[get1DIndex(row,col)]==1)
    {
        return true;
    }

    return false;
}

function fillPixel(x, y, color)
{
  var rect = new Phaser.Geom.Rectangle(x, y, 1, 1);
  graphics.fillStyle(color, 1.0);
  graphics.fillRectShape(rect);
}


    </script>
</body>
</html>
